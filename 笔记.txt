vue-admin-template是简洁版，vue-element-admin是加强版,框架使用的elementUI版本是老版本，在官网查阅时要注意切换到一致的版本文档来使用
    build文件夹--index.js文件：是webpack的配置文件，很少修改
    mock文件夹：模拟一些假数据，但实际开发中用的是真实接口
    node_modules文件夹：项目所依赖的模块
    public文件夹：icon图标、静态页面，此文件夹经常放置一些静态资源，且项目打包时webpack将该文件夹的内容原封不动打包到dist文件夹
    src文件夹
        --assets文件夹：放一些共享的静态资源，webpack打包时会对该文件夹进行编译
        --components文件夹：放置全局组件、非路由组件
        --icons文件夹：放置svg矢量图
        --layout文件夹：放置一些组件和mixin文件
        --utils文件夹--auth.js：使用cookie来存储token
    permission.js：与导航守卫相关
    settings.js：网页标题、tab栏是否随鼠标滚动而滚动、侧边栏logo是否显示...等配置项
    test文件夹：作者写的测试文件，不用看
    .env.development(/production/staging)文件：webpack配置文件，检测是开发还是生产还是测试环境
修改vue.config.js或者webpack.config这类配置文件后，要再次npm run dev来重启服务器
import * as API from '@/api'  :引入api文件夹下的文件暴露的接口，该操作引入不了api文件夹的子文件夹中的接口
调用请求接口的前缀是this.$API.default，要记得加上default
父组件通过自定义事件获取子组件三级联动的各级id, this.$emit('自定义事件名'，参数)，这里的参数写成对象形式{categoryId:category3Id,level:3}，用以区分子组件CategorySelect传给父组件Attr的是哪一级的id
由于对象存储数据是无序的，所有data中的数据1不能调用data中的数据2
深拷贝得到的备份和原来的相互独立，浅拷贝得到的备份和原来的共用一个内存，并且复杂的数据结构拷贝更常用深拷贝
原生标签中可以使用原生事件，但在element的标签中使用原生事件需要加".native"修饰符
ref 写在标签上时：this.$refs.ipt 获取的是添加了ref="ipt"标签对应的dom元素
ref 写在组件上时：this.$refs['component'] 获取到的是添加了ref="component"属性的这个组件
this.$refs[xxx]这类写法是当ref="xxx"时，xxx为变量时的写法
delete 操作符用于删除对象的属性；delete object.proerty  // 点操作符方式，常用       delete object['proerty'] //字符串属性名方式
spu管理的组件中，子组件通过v-show来控制显示隐藏，与v-if不同的是，v-show只挂载一次，而子组件每次显示都要发数据请求，所以数据请求不能写在子组件的mounted钩子中，解决办法是将数据请求的方法写在子组件的methods中，父组件通过ref获取子组件的方法发请求
v-model 是 v-model:value 的缩写，通常用于表单上的双向数据绑定（表单接受值 value，故v-model默认收集的就是 value ，所以缩写直接省略 value）
:model 是 v-bind:model 的缩写，可以实现将父组件的值传递给子组件，但是子组件不能传给父组件，无法双向绑定。
对input框来讲，失焦blur和keyup.enter.native两个事件如果用同一个回调函数，会有两次触发，在某些场景下造成第二次触发回调的参数被第一次触发修改过，不好。解决方法是两个事件使用不同的函数，或者@keyup.enter.native='$event.target.blur'
this.$options可以获取组件的配置对象，配置对象的data函数执行，返回的响应式数据为空。于是可以用Object.assign(this._data,this.$options.data())来清除响应式数据
el-select组件收集el-option组件的内容时，v-model指明收集到数据A中，这个数据A没有必要用$set创建成为双向绑定的响应式数据，因为它只负责收集，是单向的。
Vue Router和v-if/v-show一样, 是用来切换组件的显示的,Vue Router不仅仅能够切换组件的显示, 还能够在切换的时候传递参数
scoped的渲染规则
    给HTML的DOM节点加一个不重复data属性(形如：data-v-2311c06a)来表示他的唯一性
    在每句css选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器（如[data-v-2311c06a]）来私有化样式
    如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的data属性
    使用 scoped 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件有作用域的 CSS 和子组件有作用域的 CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。
    组件scoped里的样式都加了当前组件的唯一标识data属性。也就是说，即使当前组件的class跟其他组件重名，因为每个组件的data属性不一样，当前组件的样式也就不能再其他组件生效了。
    实际开发中，建议在每个组件的 style 身上都加上 scoped 属性。
    添加了scoped的父组件css样式可以通过深度选择器来作用于子组件标签(除根标签外的标签)，没添加scoped的父组件css样式可以直接作用于子组件标签(除根标签外的标签)
    深度选择器：>>>一般用于原生css,  /deep/一般用于less， ::v-deep一般用于scss(scss是sass的升级版)
canvas画布的宽高只能通过标签属性设置，不能通过css样式设置;echarts获取的盒子设置宽高，必须由css样式设置。
引用npm安装的包，import * as echarts from 'echarts'
标签内使用data和computed不需要加this，而vue组件配置项中(除watch)需要加this。
echarts图表的setOption可以多次设置，新值将覆盖旧值
通过export方式导出，在导入的时候需要加{}大括号，export default 就不需要{}.在一个文件或模块中，export,import可以有多个，export default却只能有一个。
常量路由：不管用户是什么角色权限都可以看见的路由(如登录、首页)     异步路由：需要经过筛选来展示给不同权限的用户的路由       任意路由：当路径出现错误时，重定向至404页面
在vuex仓库中引入路由js文件中的异步(and常量and任意)路由对象数组，和服务器获取来的用户路由信息对比，在actions配置项中commit('ABCDE',对比函数)，(多级路由用递归来对比)，处理结果和常量(and任意)路由进行合并，在vuex仓库中引入路由router使用router.addRoutes()添加新路由，相应组件遍历该新路由进行展示
原生事件只能绑定在原生DOM上，绑在组件标签上视为自定义事件(需要加.native才能被视为原生事件)。自定义事件绑定在组件标签上，若绑定在原生DOM上是无法触发的，因为原生DOM不是组件，缺少$emit等属性和方法
原生DOM标签中的" :value='xxx' ",是单向绑定。组件标签中的" :value='xxx' ",是通过props向子组件传变量(props传数据，不加冒号传的是字符串，加冒号传的是变量)
原生DOM标签中的" v-model='xxx' ",是当前组件的数据双向绑定。组件标签中的" v-model='xxx' ",是实现父子组件的数据同步
组件标签中：      :value='xxx'是父组件用props传变量给子组件，而:value.sync='xxx'是实现父子组件数据同步(本质上给当前子组件标签绑定了自定义事件'update:xxx')
vm.$attrs是一个对象，包含当前组件的父组件传来的props数据(即props配置项没有接收的数据)。v-bind=$attrs将$attrs中的属性都绑定到标签上面
vm.$listeners是一个对象，可以获取到父组件中给子组件传递的"自定义事件"。v-on="$listeners"将父组件传递来的事件绑定到当前子组件上
vm.$children是一个数组(该数组不保证子组件的顺序)，可以获取到当前组件的所有子组件。      vm.$parent可以获取当前组件的父组件
项目中若某个JS业务逻辑常用，可以使用mixin
作用域插槽：结构在父组件，数据在子组件，意义在于让外部来拓展子组件的结构。  子组件中<slot :todo="obj1"></slot>传数据，父组件中<template slot-scope="obj2"></template>接收数据。